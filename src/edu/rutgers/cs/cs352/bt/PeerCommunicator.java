/**
 * 
 */
package edu.rutgers.cs.cs352.bt;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.lang.reflect.Array;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.Arrays;
import java.util.Random;
import java.util.logging.Logger;

/**
 * @author Julian Modesto
 *
 */
public class PeerCommunicator extends Thread {
	
	private final static Logger LOGGER = 
			Logger.getLogger(PeerCommunicator.class.getName());
	
	// Hard code the first 4 bytes of the peer ID
	private static final byte[] GROUP = {'G','P','1','6'};
	
	// Chocked status
	// local client = us
	// remote client = them
	private boolean localChoked; 
	private boolean remoteChoked;
	private boolean localInterested;
	private boolean remoteInterested;
	
	// Flag to keep the peer running
	private boolean keepRunning;
	
	private Socket socket;
	private DataInputStream dataIn;
	private DataOutputStream dataOut;
	
	private byte[] peerId;
	private String address;
	private int port;
	private byte[] infohash;
	private byte[] myPeerId;
	
	private PeerCommunicator(byte[] peerId, String address, int port, byte[] infohash, byte[] myPeerId) {
		this.peerId = peerId;
		this.address = address;
		this.port = port;
		this.infohash = infohash;
		this.myPeerId = myPeerId;
	}
	
	/**
	 * 
	 * @return the generated ID
	 */
	private byte[] generatePeerId() {
		byte[] peerId = new byte[20];
		
		// Hard code the first four bytes for easy identification
		System.arraycopy(GROUP, 0, peerId, 0, GROUP.length);
		
		// Randomly generate remaining 16 bytes
		new Random().nextBytes(peerId);
		
		return peerId;
	}
	
	/**
	 * Generates the handshake from the client to the peer.
	 * 
	 * The byte array is preallocated and then filled with System.arraycopy.
	 * 
	 * @author Julian Modesto
	 * @param infohash the 20-byte SHA-1 hash of the bencoded form of the info value from the metainfo (.torrent) file
	 * @param peerId the peer id generated by the client
	 * @return the handshake byte array
	 */
	private byte[] getHandshake() {
		// Preallocate bytes for handshake
		byte[] handshake = new byte[68];
		
		// Header 19:BitTorrent protocol
		// Begin with byte 19
		handshake[0] = 19;
		
		// Add "BitTorrent protocol"
		final byte[] PROTOCOL = {'B','i','t','T','o','r','r','e','n','t',' ',
				'p','r','o','t','o','c','o','l'};
		System.arraycopy(PROTOCOL, 0, handshake, 1, PROTOCOL.length);
		
		// 8 reserved bytes 20-27 are already initialized to 0; skip + omit commented-out code below
		
		// Add infohash SHA-1 hash - not encoded
		System.arraycopy(infohash, 0, handshake, 28, this.infohash.length);
		
		// Add peer id, which should match the infohash
		System.arraycopy(peerId, 0, handshake, 48, this.peerId.length);	
		
		LOGGER.info("Generated handshake");
		
		return handshake;
	}
	
	/**
	 * Validate two handshakes for equality
	 * 
	 * @param myHandshake
	 * @param otherHandshake
	 * @return the truth value for the equality of the handshakes
	 */
	private boolean validateHandshake(byte[] myHandshake, byte[] otherHandshake) {
		
		if (myHandshake == null || otherHandshake == null) {
			return false;
		}
		
		if (myHandshake.length != otherHandshake.length) {
			return false;
		}
		
		// Skip header and reserved bytes
		
		// Check info hash
		byte[] myInfoHash = new byte[20];
		byte[] otherInfoHash = new byte[20];
		
		System.arraycopy(myHandshake, 28, myInfoHash, 0, 20);
		System.arraycopy(otherHandshake, 28, otherInfoHash, 0, 20);
		
		if (!Arrays.equals(myInfoHash, otherInfoHash)) {
			return false;
		}
		
		// Check peer ID
		byte[] myPeerId = new byte[20];
		byte[] otherPeerId = new byte[20];
		
		System.arraycopy(myHandshake, 48, myPeerId, 0, 20);
		System.arraycopy(otherHandshake, 48, otherPeerId, 0, 20);
		
		if (!Arrays.equals(myPeerId, otherPeerId)) {
			return false;
		}
		
		return true;
	}
	
	/**
	 * @throws IOException 
	 * 
	 */
	private void connect() throws IOException {
		
		// Check that port number is within standard TCP range i.e. max port number is an unsigned, 16-bit short = 2^16 - 1 = 65535
		if (port <= 0 | port >= 65535) {
			LOGGER.warning("Error: port number" + port + "is out of bounds");
			return;
		}
		
		// Create socket
		socket = null;
		try {
			socket = new Socket(this.address, port);
		} catch (UnknownHostException uhe) {
			LOGGER.severe("Error: the IP address of the host could not be determined from " + this.address);
			LOGGER.severe(uhe.getMessage());
		} catch (IOException ioe) {
			LOGGER.severe("Error: an I/O error occurred");
			LOGGER.severe(ioe.getMessage());
		}
		
		// Check if connected once but not closed
		if (socket == null && !socket.isClosed()) {
			LOGGER.severe("Error: socket connected once but not closed");
		}
		
		// Open IO streams
		dataIn = new DataInputStream(socket.getInputStream());
		dataOut = new DataOutputStream(socket.getOutputStream());
	}
	
	public void run() {
		try {
			connect();
			
			byte[] myHandshake = getHandshake();
			dataOut.write(myHandshake);
			dataOut.flush();
			
			byte[] peerHandshake = new byte[68];
			dataIn.readFully(peerHandshake);
			
			// Main loop
			while (this.keepRunning) {
				// read message from socket
				PeerMessage message = PeerMessage.read(this.dataIn);
				if (message == null) {
					//error
				}
				//switch(msg.getType())
				//inspect bitfield
				//receive message, update internal state i.e. MESSAGE_CHOKEd => (?) localChoked = true;
				//pass message to client
				//send interest message, localInterested = true;
			}
			
//			dataIn.readFully(b);
			
			// Close IO streams
			dataIn.close();
			dataOut.flush();
			dataOut.close();
			
			// Close socket
			socket.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	/**
	 * 
	 */
	public void getAvailablePieces() {
		
	}
	
	/**
	 * 
	 */
	public void sendInterestedInPiece() {
		
	}
	
	/**
	 * 
	 */
	public void requestPiece() {
		
	}
}
