/**
 * 
 */
package edu.rutgers.cs.cs352.bt;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.Socket;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.Random;
import java.util.logging.Logger;

/**
 * @author Julian Modesto
 *
 */
public class PeerCommunicator extends Thread {
	
//	private final static Logger LOGGER = 
//			Logger.getLogger(PeerCommunicator.class.getName());
	
	// Hard code the first 4 bytes of the peer ID
	private static final byte[] GROUP = {'G','P','1','6'};
	
	// Choked status and interested status of client and peer
	private boolean amChoking; // this client is choking the peer
	private boolean peerChoking; // peer is choking this client
	private boolean amInterested; // this client is interested in the peer
	private boolean peerInterested; // peer is interested in this client
	
	// Flag to keep the peer running
	private boolean keepRunning;
	
	private Socket socket;
	private DataInputStream dataIn;
	private DataOutputStream dataOut;
	
	private byte[] peerId;
	private String address;
	private int port;
	private byte[] infohash;
	private byte[] myPeerId;
	
	private PeerCommunicator(byte[] peerId, String address, int port, byte[] infohash, byte[] myPeerId) {
		this.peerId = peerId;
		this.address = address;
		this.port = port;
		this.infohash = infohash;
		this.myPeerId = myPeerId;
		
		// Set default states
		this.amChoking = true;
		this.peerChoking = true;
		this.amInterested = false;
		this.peerInterested = false;
	}
	
	/**
	 * 
	 * @return the generated ID
	 */
	private byte[] generatePeerId() {
		byte[] peerId = new byte[20];
		
		// Hard code the first four bytes for easy identification
		System.arraycopy(GROUP, 0, peerId, 0, GROUP.length);
		
		// Randomly generate remaining 16 bytes
		new Random().nextBytes(peerId);
		
		return peerId;
	}
	
	/**
	 * Generates the handshake from the client to the peer.
	 * 
	 * The byte array is preallocated and then filled with System.arraycopy.
	 * 
	 * @author Julian Modesto
	 * @param infohash the 20-byte SHA-1 hash of the bencoded form of the info value from the metainfo (.torrent) file
	 * @param peerId the peer id generated by the client
	 * @return the handshake byte array
	 */
	private byte[] getHandshake() {
		// Preallocate bytes for handshake
		byte[] handshake = new byte[68];
		
		// Header 19:BitTorrent protocol
		// Begin with byte 19
		handshake[0] = 19;
		
		// Add "BitTorrent protocol"
		final byte[] PROTOCOL = {'B','i','t','T','o','r','r','e','n','t',' ',
				'p','r','o','t','o','c','o','l'};
		System.arraycopy(PROTOCOL, 0, handshake, 1, PROTOCOL.length);
		
		// 8 reserved bytes 20-27 are already initialized to 0; skip + omit commented-out code below
		
		// Add infohash SHA-1 hash - not encoded
		System.arraycopy(infohash, 0, handshake, 28, this.infohash.length);
		
		// Add peer id, which should match the infohash
		System.arraycopy(peerId, 0, handshake, 48, this.peerId.length);	
		
		System.out.println("Generated handshake.");
		
		return handshake;
	}
	
	/**
	 * Validate two handshakes for equality
	 * 
	 * @param myHandshake
	 * @param otherHandshake
	 * @return the truth value for the equality of the handshakes
	 */
	private boolean validateHandshake(byte[] otherHandshake) {
		
		if (otherHandshake == null) {
			return false;
		}
		
		if (otherHandshake.length != 68) {
			return false;
		}
		
		// Skip header and reserved bytes
		
		// Check info hash
		byte[] otherInfoHash = new byte[20];
		System.arraycopy(otherHandshake, 28, otherInfoHash, 0, 20);
		if (!Arrays.equals(this.infohash, otherInfoHash)) {
			return false;
		}
		
		System.out.println("Handshake validated.");
		
		return true;
	}
	
	/**
	 * @throws IOException 
	 * 
	 */
	private void connect() throws IOException {
		
		// Check that port number is within standard TCP range i.e. max port number is an unsigned, 16-bit short = 2^16 - 1 = 65535
		if (port <= 0 | port >= 65535) {
			System.err.println("Error: port number" + port + "is out of bounds");
			return;
		}
		
		// Create socket
		socket = null;
		try {
			socket = new Socket(this.address, port);
		} catch (UnknownHostException uhe) {
			System.err.println("Error: the IP address of the host could not be determined from " + this.address + ".");
			System.err.println(uhe.getMessage());
		} catch (IOException ioe) {
			System.err.println("Error: an I/O error occurred.");
			System.err.println(ioe.getMessage());
		}
		
		// Check if connected once but not closed
		if (socket == null && !socket.isClosed()) {
			System.err.println("Error: socket connected once but not closed.");
		}
		
		// Open IO streams
		dataIn = new DataInputStream(socket.getInputStream());
		dataOut = new DataOutputStream(socket.getOutputStream());
	}
	
	public void run() {
		try {
			// Connect
			connect();
			
			// Send handshake
			byte[] myHandshake = getHandshake();
			dataOut.write(myHandshake);
			dataOut.flush();
			
			// Read response
			byte[] peerHandshake = new byte[68];
			dataIn.readFully(peerHandshake);
			
			// Validate handshake against info hash from .torrent file
			validateHandshake(peerHandshake);
			
			// Set peer ID
			System.arraycopy(peerHandshake, 48, this.peerId, 0, 20);
			
			// Main loop
			while (this.keepRunning) {
				// read message from socket
				PeerMessage message = PeerMessage.read(this.dataIn);
				if (message == null) {
					System.err.println("Error: no message.");
				}
				
				switch (message.getType()) {
				case PeerMessage.TYPE_KEEP_ALIVE:
					break;
				case PeerMessage.TYPE_CHOKE:
					break;
				case PeerMessage.TYPE_UNCHOKE:
					break;
				case PeerMessage.TYPE_INTERESTED:
					break;
				case PeerMessage.TYPE_UNINTERESTED:
					break;
				case PeerMessage.TYPE_HAVE:
					break;
				case PeerMessage.TYPE_REQUEST:
					break;
				case PeerMessage.TYPE_PIECE:
					break;
				}
				//inspect bitfield
				//receive message, update internal state i.e. MESSAGE_CHOKEd => (?) localChoked = true;
				//pass message to client
				//send interest message, localInterested = true;
			}
						
			// Close IO streams
			dataIn.close();
			dataOut.flush();
			dataOut.close();
			
			// Close socket
			socket.close();
			
			
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	/**
	 * 
	 */
	public void getAvailablePieces() {
		
	}
	
	/**
	 * 
	 */
	public void sendInterestedInPiece() {
		
	}
	
	public void verifyPiece(byte[] piece) {
		try {
			MessageDigest sha = MessageDigest.getInstance("SHA-1");
			byte[] hash = sha.digest(piece);
		} catch (NoSuchAlgorithmException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	/**
	 * 
	 */
	public void requestPiece() {
		
	}
}
